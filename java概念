# java-notes
java中需要注意的概念
访问控制符：
    private：只在同一个类中可见、
    protect：在同一个类中、同一个包中、不同包中的子类中可见
    public：均可见
    默认：没有访问控制符时，在同一个类中同一个包中可见。
 非访问控制符：
     static：静态的、非实例的、类的（可以修饰内部类和成员变量）
     final：最终的、不接改变的（可以修饰内部类和成员变量以及局部变量）
     abstract：抽象的、不可实例化的（可以修饰内部类和成员变量）
  static字段：
            静态字段最本质的特点是：它们是类的字段，不属于任何一个对象实例。
        • 它不保存在某个对象实例的内存区间中，而是保存在类的内存区域的公共存储单元。
        • 类变量可以通过类名直接访问，也可以通过实例对象来访问，两种方法的结果是相同的。
        • 如System类的in和out对象，就是属于类的域，直接用类名来访问，即System.in和System.out。
   static字段：
          用static修饰符修饰的方法仅属于类的静态方法，又称为类方法。
        • 与此相对，不用static修饰的方法，则为实例方法。
        • 类方法的本质是该方法是属于整个类的，不是属于某个实例的。
        • 声明一个方法为static有以下几重含义。
            (1) 非static的方法是属于某个对象的方法，在这个对象创建时，对象的方法在内存中拥有自己专用的代码段。而static的方法是属于整个类的，它在内存中的代码段将随着类的定义而进行分配和装载，不被任何一个对象专有。
            (2) 由于static方法是属于整个类的，所以它不能操纵和处理属于某个对象的成员变量，而只能处理属于整个类的成员变量，即static方法只能处理本类中的static域或调用static方法。
            (3) static方法中，不能访问实例变量， 不能使用this 或super。
            (4) 调用这个方法时，应该使用类名直接调用，也可以用某一个具体的对象名。
               例如： Math.random()， Integer.parseInt()等就是类方法，直接用类名进行访问。
    final类：
        如果一个类被final修饰符所修饰和限定，说明这个类不能被继承，即不可能有子类。
    final方法：
        final修饰符所修饰的方法，是不能被子类所覆盖的方法。
        
    final字段及final局部变量：   
           它们的值一旦给定，就不能更改。是只读量，它们能且只能被赋值一次，而不能被赋值多次。
           一个字段被static final两个修饰符所限定时， 它可以表示常量，如Integer. MAX_VALUE(表示最大整数)、 Math.PI(表示圆周率)就是这种常量。
           关于赋值在定义static final域时，若不给定初始值，则按默认值进行初始化（数值为0， boolean型为false，引用型为null）。
           在定义final字段时，若不是static的域，则必须且只能赋值一次，不能缺省。
           这种域的赋值的方式有两种： 一是在定义变量时赋初始值，二是在每一个构造函数中进行赋值。
           在定义final局部变量时，也必须且只能赋值一次。它的值可能不是常量，但它的取值在变量存在期间不会改变。
     1． abstract类
          凡是用abstract修饰符修饰的类被称为抽象类。
          抽象类不能被实例化
     2． abstract方法
          被abstract所修饰的方法叫抽象方法，抽象方法的作用在为所有子类定义一个统一的接口。对抽象方法只需声明，而不需实现， 即用分号（；）而不是用{}，格式如下：
          abstract returnType abstractMethod( [paramlist] );抽象类中可以包含抽象方法，也可以不包含abstract方法。但是，一旦某个类中包含了abstract方法，则这个类必须声明为abstract类。
          抽象方法在子类中必须被实现，否则子类仍然是abstract的。
    接口（interface）
         接口，某种特征的约定：（使用方法和参数来说明约定的特征）
         定义接口 （interface）
                所有方法都是自动是public abstract
         实现接口  (implements)
                可以实现多继承
                与类的继承关系无关
          面向接口编程，而不是面向实现
          1. 通过接口可以实现不相关类的相同行为，而不需要考虑这些类之间的层次关系。从而在一定意义上实现了多重继承。
          2. 通过接口可以指明多个类需要实现的方法。
          3. 通过接口可以了解对象的交互界面，而不需了解对象所对应的类。
  
  字段变量和局部变量区别：
       前者是在类中的变量，后者是在方法中定义的变量或者方法的参变量
       
      基本类型(primitive type)：其值直接存于变量中。“在这里”
      引用型(reference type) 的变量除占据一定的内存空间外，它所引用的对象实体（由new 创建）也要占据一定空间。“在那里”
   从内存角度看
        存储位置，字段变量为对象的一部分、存在于堆中的，局部变量是存在于栈中。
        生命周期不同（一个随着对象存在而存在，一个是随着方法调用而存在，方法调用结束而消亡）
        初始值：字段变量可以自动赋初值，局部变量则须显式赋值
   从语法角度看
        字段变量属于类，可以用public,private,static,final 修饰。
        局部变量不能够被访问控制符及static修饰
        都可以被final修饰
    调用对象方法时，要传递参数。在传递参数时，Java 是值传递，即，是将表达式的值复制给形式参数。
    对于引用型变量，传递的值是引用值，而不是复制对象实体，可以改变对象的属性
    
    
    多态(Polymorphism)：是指一个程序中相同的名字表示不同的含义的情况。
       多态有两种情形：
             编译时多态：
            • 重载(overload) （多个同名的不同方法） 。
            • 如 p.sayHello(); p.sayHello(“Wang”);
             运行时多态：
            • 覆盖(override) （子类对父类方法进行覆盖）
            • 动态绑定（ dynamic binding）也称----虚方法调用(virtual method invoking)
            • 在调用方法时，程序会正确地调用子类对 象的方法。
            • 多态的特点大大提高了程序的抽象程度和简洁性
        动态绑定：是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法  
            用虚方法调用，可以实现运行时的多态！
                子类重载了父类方法时，运行时
                运行时系统根据调用该方法的实例的类型来决定选择哪个方法调用
                所有的非final方法都会自动地进行动态绑定！
            动态绑定的过程：
                虚拟机提取对象的实际类型的方法表；
                虚拟机搜索方法签名；
                调用方法
         •static的方法，以声明的类型为准，与实例类型无关
         • private方法子类看不见，也不会被虚化
         • final方法子类不能覆盖，不存在虚化问题、
         
         构造方法：（一定是先调用父类的构造方法最后调用子类的构造方法）
            • 调用本类或父类的构造方法
                    this调用本类的其他构造方法。
                    super调用直接父类的构造方法
                    this或super要放在第一条语句,且只能够有一条
             • 如果没有this及super，则编译器自动加上super()，即调用直接父类不带参数的构造方法
             • 因为必须令所有父类的构造方法都得到调用，否则整个对象的构建就可能不正确。

             • 构造方法的执行过程遵照以下步骤：
                    调用本类或父类的构造方法，直至最高一层（ Object）
                    按照声明顺序执行字段的初始化赋值
                    执行构造函数中的各语句
              • 简单地说：
                    先父类构造，再本类成员赋值，最后执行构造方法中的语句。
  
             • 但Object的finalize() 有类似c++中的析构函数的功能
                    系统在回收时会自动调用对象的finalize() 方法。
                    protected void finalize() throws Throwable{}
             • 子类的finalize()方法
                    可以在子类的finalize()方法释放系统资源
                    一般来说，子类的finalize()方法中应该调用父类的finalize()方法，以保证父类的清理工作能够正常进行。
 
   类：是对象的模板或蓝图，是一个抽象概念。
   对象：是类的具体化，类的实例化。
   java中的包都是由小写单词组成的。类的名字开头必须大写，如果由多个单词组成，建议最好每个单词开头大写。方法的名字第一个单词应小写，后面的单词则大写开头例如：sendMessage();
   参数的命名和方法的命名规则一样；
   对象的变量也成为实例变量；隶属于对象的实例变量和实例方法统称为实例成员；
   静态成员是隶属于类的，不属于任何一个对象，并且在加载时就会初始化静态变量，静态变量和静态方法统称为静态成员。
   java中有两种值：对象的引用和元数据类型值；
   注意：不能再静态方法中使用非静态变量；
   java的关键字都是小写的；
   java 的两种数据类型：
              原始数据类型，分为boolean,byte,in,char,long,short,double,float
              引用数据类型 ，分为数组,类,接口
   int  和  Integer的区别：
             int是原始数据类型，直接存数值，初始化的int型值为0；
             Integer是对象，用一个引用指向这个对象，初始化则为null；
   ### Java为每个原始类型提供了封装类；为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，
       Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，
       从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。
   原始类型: boolean，char，byte，short，int，long，float，double
   封装类类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double
   
   
   自动装箱：将基本数据类型重新转化为对象（例如：将int型转化为Integer对象）  
             public class Test {  
                 public static void main(String[] args) {  
                //声明一个Integer对象
                Integer num = 9;
            //以上的声明就是用到了自动的装箱：解析为:Integer num = new Integer(9);
          }  
       }  
   自动拆箱：将对象重新转化为基本数据类型（对一个对象进行数据操作会进行拆箱变为基本数据类型后然后进行运算）
        public class Test {  
        public static void main(String[] args) {  
            //声明一个Integer对象
            Integer num = 9;

            //进行计算时隐含的有自动拆箱
            System.out.print(num--);//因为对象时不能直接进行运算的，而是要转化为基本数据类型后才能进行加减乘除。
        }  
    }  
    装箱和拆箱进行对比：
         //装箱
        Integer num = 10;
        //拆箱
        int num1 = num;
  
  java中length 和 length()的区别？
     Java的String类可以定义字符串变量和字符串数组；如String s1 = new String("abcdef");//字符串变量  String[] s2 ={"andy","danmon","lily","selina"};//字符串数组
        length()用于计算字符串变量的长度，length用于计算字符串数组的长度
        s1.length()// 7
        s2.length// 4
      计算数组的长度用length；数组的大小不能改变，可以重新创建新数组
      size()是针对泛型数组求长度的方法
      
      单例模式VS静态类
            1. 单例可以继承和被继承，方法可以被override，而静态方法不可以。
            2. 静态方法中产生的对象会在执行后被释放，进而被GC清理，不会一直存在于内存中。
            3. 静态类会在第一次运行时初始化，单例模式可以有其他的选择，即可以延迟加载。
            4. 基于2， 3条，由于单例对象往往存在于DAO层（例如sessionFactory），如果反复的初始化和释放，则会占用很多资源，而使用单例模式将其常驻于内存可以更加节约资源。
            5. 静态方法有更高的访问效率。
            6. 单例模式很容易被测试。
        几个关于静态类的误解：
            误解一：静态方法常驻内存而实例方法不是。
            实际上，特殊编写的实例方法可以常驻内存，而静态方法需要不断初始化和释放。
            误解二：静态方法在堆(heap)上，实例方法在栈(stack)上。
            实际上，都是加载到特殊的不可写的代码内存区域中。
        静态类和单例模式情景的选择：
            情景一：不需要维持任何状态，仅仅用于全局访问，此时更适合使用静态类。
            情景二：需要维持一些特定的状态，此时更适合使用单例模式。
       
 
 
 
 
