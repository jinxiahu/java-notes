简单工厂模式：
       由三部分组成：具体工厂，具体产品和抽象产品。其中具体产品是抽象产品的派生类
工厂类（Creator）角色：担任这个角色的是简单工厂模式的核心，含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象，它往往由一个具体的java类实现。
抽象产品角色（AbstructProduct）角色：担任这个角色的类是由简单工厂模式所创建对象的父类，或它们共同拥有的接口。抽象产品角色可以用一个java接口或者java抽象类实现。
具体产品（ConcreteProduct）角色：简单工厂模式所创建的任何对象都是这个角色的实例，具体产品角色由一个具体Java类实现。
模式动机：
    使用简单工厂模式可以将产品的“消费”和生产完全分开，客户端只需要知道自己需要什么产品，如何使用产品就可以了，具体的产品生产任务由具体的工厂类来实现。
 工厂类根据传进来的参数生产具体的产品供消费者使用。这种模式使得更加利于扩展，当有新的产品加入是仅仅需要在工厂中加入新产品的构造就可以了。
 
 简单工厂模式的优点：     
    1.工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。
    2.客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
    3.通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。
    4.当需要引入新的产品是不需要修改客户端的代码，只需要添加相应的产品类并修改工厂类就可以了，所以说从产品的角度上简单工厂模式是符合“开-闭”原则的。

简单工厂模式的缺点：     
    1.由于工厂类集中了所有产品创建逻辑，工厂类一般被我们称作“全能类”或者“上帝类”，因为所有的产品创建他都能完成，这看似是好事，但仔细想想是有问题的。比如全国上下所有的事情都有国家主义一个人干会不会有问题，当然有！一旦不能正常工作，整个系统都要受到影响。
    2.使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
    3.系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。所以说从工厂的角度来说简单工厂模式是不符合“开-闭”原则的。
    4.简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。
适用场景：
    1、工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
    2、客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。
  
  
  java设计模式之策略模式：
       由环境角色（Context），抽象策略角色（Strategy）和具体策略模式（ConcreteStrategy）组成
       源代码：
               Context类
                 public class Context {
                  //持有一个具体策略的对象
                 private Strategy strategy;
                  /**
                   * 构造函数，传入一个具体策略对象
                   * @param strategy    具体策略对象
                   */
                  public Context(Strategy strategy){
                      this.strategy = strategy;
                  }
                  /**
                   * 策略方法
                   */
                  public void contextInterface(){

                      strategy.strategyInterface();
                  }

              }
              
          抽象策略类：
                  public interface Strategy {
                         /**
                          * 策略方法
                          */
                  public void strategyInterface();
              }
              
              具体策略类
              public class ConcreteStrategyA implements Strategy {

                  @Override
                  public void strategyInterface() {
                      //相关的业务
                  }
              }
              public class ConcreteStrategyB implements Strategy {

                  @Override
                  public void strategyInterface() {
                      //相关的业务
                  }
              }


              public class ConcreteStrategyC implements Strategy {

                  @Override
                  public void strategyInterface() {
                      //相关的业务
                  }
              }
              
              策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。

    策略模式的重心
　　策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。

　　算法的平等性
　　策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。

　　运行时策略的唯一性
　　运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。

　　公有的行为
　　经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。这其实也是典型的将代码向继承等级结构的上方集中的标准做法。

    策略模式的优点
　　（1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。
　　（2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。

策略模式的缺点
　　（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。
　　（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。
  
    面向对象设计原则：
       基础原则：开闭原则（OCP）：对扩展开放，对修改
       单一职责原则（SRP）：就一个类而言，应该仅有一个引起它变化的原因
                         （在构造对象时，应将对象的不同职责分离至多个类中，从而确保引起该类变化的原因只有一个。使用此原则可以提高高内聚，降低耦合度）
       里氏替换原则（LSP）：若对每个类S的对象O1，都存在一个类T的对象O2，使得在所有针对T编写的程序P中，用O1替换O2后，程序P的功能不变，则S是T的子类。
                           实现继承时，子类必须能替换掉它们的基类。
       依赖倒置原则（DIP）：高层模块不应该依赖低层模块。两者都应该依赖对象。抽象对象不应该依赖细节，细节应该依赖抽象，也就是不要针对实现编程要针对接口编程。
       接口隔离原则（ISP）：不要强迫客户端依赖于它们不需要的方法，应该用接口将两者隔离。
     
     什么叫高层依赖低层？
         面向过程的开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多的函数的程序库，这样我们在做新项目时区调用这些低层函数就可以。这就是高层模块依赖低层模块。
           
         

            
